pragma solidity ^0.5.3;

contract AccountManager {
    struct AccountAccessDetails {
        address acctId;
        string orgId;
        string role;
        bool active;
    }

    AccountAccessDetails[] private acctAccessList;
    mapping(address => uint) private accountIndex;
    uint private numberOfAccts;

    // account permission events
    event AccountAccessModified(address _address, string _roleId);
    // Get account details given index

    function getAccountDetails(address _acct) external view returns (address acct, string memory orgId, string memory role, bool active)
    {
        uint aIndex = getAcctIndex(_acct);
        return (acctAccessList[aIndex].acctId, acctAccessList[aIndex].orgId, acctAccessList[aIndex].role, acctAccessList[aIndex].active);
    }

    // Get number of accounts
    function getNumberOfAccounts() external view returns (uint)
    {
        return acctAccessList.length;
    }

    function assignAccountRole(address _address, string calldata _orgId, string calldata _roleId) external
    {
        // Check if account already exists
        uint aIndex = getAcctIndex(_address);
        if (accountIndex[_address] != 0) {
            acctAccessList[aIndex].role = _roleId;
        }
        else {
            numberOfAccts ++;
            accountIndex[_address] = numberOfAccts;
            acctAccessList.push(AccountAccessDetails(_address, _orgId, _roleId, true));
        }
        emit AccountAccessModified(_address, _roleId);
    }

    function getAccountRole(address _acct) external view returns (string memory) {
        if (accountIndex[_acct] == 0) {
            return "NONE";
        }
        else {
            uint acctIndex = getAcctIndex(_acct);
            return acctAccessList[acctIndex].role;
        }
    }
    // Returns the account index based on account id
    function getAcctIndex(address _acct) internal view returns (uint)
    {
        return accountIndex[_acct] - 1;
    }

}

contract RoleManager {
    enum AccountAccess {ReadOnly, Transact, ContractDeploy, FullAccess}
    struct RoleDetails {
        string roleId;
        string orgId;
        AccountAccess baseAccess;
        bool isVoter;
        bool active;
    }

    RoleDetails[] private roleList;
    mapping(bytes32 => uint) private roleIndex;
    uint private numberOfRoles;

    event RoleCreated(string _roleId, string _orgId);
    event RoleRevoked(string _roleId, string _orgId);

    constructor (string memory _roleId, string memory _orgId, RoleManager.AccountAccess _baseAccess, bool _voter) public {
        addRole(_roleId, _orgId, _baseAccess, _voter);
    }

    function getRoleDetails(string calldata _roleId, string calldata _orgId) external view returns (string memory roleId, string memory orgId, RoleManager.AccountAccess accessType, bool voter, bool active)
    {
        uint rIndex = getRoleIndex(_roleId, _orgId);
        return (roleList[rIndex].roleId, roleList[rIndex].orgId, roleList[rIndex].baseAccess, roleList[rIndex].isVoter, roleList[rIndex].active);
    }

    // Get number of Role
    function getNumberOfRole() external view returns (uint)
    {
        return roleList.length;
    }

    function addRole(string memory _roleId, string memory _orgId, RoleManager.AccountAccess _baseAccess, bool _voter) public
    {
        // Check if account already exists
        if (roleIndex[keccak256(abi.encodePacked(_roleId, _orgId))] == 0) {
            numberOfRoles ++;
            roleIndex[keccak256(abi.encodePacked(_roleId, _orgId))] = numberOfRoles;
            roleList.push(RoleDetails(_roleId, _orgId, _baseAccess, _voter, true));
        }
        emit RoleCreated(_roleId, _orgId);
    }

    function removeRole(string calldata _roleId, string calldata _orgId) external{
        if (roleIndex[keccak256(abi.encodePacked(_roleId, _orgId))] != 0) {
            uint rIndex = getRoleIndex(_roleId, _orgId);
            roleList[rIndex].active = false;
            emit RoleRevoked(_roleId, _orgId);
        }
    }
    // Returns the account index based on account id
    function getRoleIndex(string memory _roleId, string memory _orgId) internal view returns (uint)
    {
        return roleIndex[keccak256(abi.encodePacked(_roleId, _orgId))] - 1;
    }

    function isFullAccessRole(string calldata _roleId, string calldata _orgId) external view returns (bool){
        uint rIndex = getRoleIndex(_roleId, _orgId);
        return (roleList[rIndex].baseAccess == AccountAccess.FullAccess);
    }

    function isVoterRole(string calldata _roleId, string calldata _orgId) external view returns (bool){
        uint rIndex = getRoleIndex(_roleId, _orgId);
        return (roleList[rIndex].isVoter);
    }

}

contract OrgVoterManager {
    enum PendingOpType {None, OrgAdd, OrgRemoval}
    struct PendingOpDetails {
        string orgId;
        string enodeId;
        PendingOpType opType;
    }

    struct VoterDetails {
        address vAccount;
        bool active;
    }

    struct OrgVoterDetails {
        string orgId;
        uint voterCount;
        uint validVoterCount;
        uint voteCount;
        PendingOpDetails pendingOp;
        VoterDetails [] voterList;
        mapping(address => uint) voterIndex;
        mapping(uint => mapping(address => bool)) votingStatus;
    }

    OrgVoterDetails [] private orgVoterList;
    mapping(bytes32 => uint) private VoterOrgIndex;
    uint private orgNum = 0;

    // events related to managing voting accounts for the org
    event VoterAdded(string _orgId, address _address);
    event VoterDeleted(string _orgId, address _address);

    event VotingItemAdded(string _orgId);
    event VoteProcessed(string _orgId);

    // returns the voter index
    function getVoterIndex(string memory _orgId, address _vAccount) internal view returns (uint)
    {
        uint orgIndex = getVoterOrgIndex(_orgId);
        return orgVoterList[orgIndex].voterIndex[_vAccount] - 1;
    }

    // returns the master org index for the org from voter list
    function getVoterOrgIndex(string memory _orgId) internal view returns (uint)
    {
        return VoterOrgIndex[keccak256(abi.encodePacked(_orgId))] - 1;
    }

    // checks if the org has any voter accounts set up or not
    function checkIfVoterExists(string memory _orgId, address _address) public view returns (bool){
        uint orgIndex = getVoterOrgIndex(_orgId);
        if (orgVoterList[orgIndex].voterIndex[_address] == 0) {
            return false;
        }
        uint voterIndex = getVoterIndex(_orgId, _address);
        return orgVoterList[orgIndex].voterList[voterIndex].active;
    }

    // Get number of total voters
    function getNumberOfVoters(string calldata _orgId) external view returns (uint)
    {
        return orgVoterList[getVoterOrgIndex(_orgId)].voterCount;
    }

    // Get number of valid voters
    function getNumberOfValidVoters(string calldata _orgId) external view returns (uint)
    {
        return orgVoterList[getVoterOrgIndex(_orgId)].validVoterCount;
    }

    // Get voter details
    function getVoter(string calldata _orgId, uint i) external view returns (address _addr, bool _active)
    {
        uint orgIndex = getVoterOrgIndex(_orgId);
        return (orgVoterList[orgIndex].voterList[i].vAccount, orgVoterList[orgIndex].voterList[i].active);
    }


    // checks if the voting accounts exists for the org
    function checkVotingAccountExists(string calldata _orgId) external view returns (bool)
    {
        uint orgIndex = getVoterOrgIndex(_orgId);
        return (orgVoterList[orgIndex].validVoterCount > 0);
    }

    // function for adding a voter account to a master org
    function addVoter(string calldata _orgId, address _address) external
    {
        // check if the org exists
        if (VoterOrgIndex[keccak256(abi.encodePacked(_orgId))] == 0) {
            orgNum++;
            VoterOrgIndex[keccak256(abi.encodePacked(_orgId))] = orgNum;
            uint id = orgVoterList.length++;
            orgVoterList[id].orgId = _orgId;
            orgVoterList[id].voterCount = 1;
            orgVoterList[id].validVoterCount = 1;
            orgVoterList[id].voteCount = 0;
            orgVoterList[id].pendingOp.orgId = "";
            orgVoterList[id].pendingOp.enodeId = "";
            orgVoterList[id].pendingOp.opType = PendingOpType.None;
            orgVoterList[id].voterIndex[_address] = orgVoterList[id].voterCount;
            orgVoterList[id].voterList.push(VoterDetails(_address, true));
        }
        else {
            uint id = getVoterOrgIndex(_orgId);
            orgVoterList[id].voterCount++;
            orgVoterList[id].validVoterCount++;
            orgVoterList[id].voterIndex[_address] = orgVoterList[id].voterCount;
            orgVoterList[id].voterList.push(VoterDetails(_address, true));
        }
        emit VoterAdded(_orgId, _address);
    }

    // function for deleting a voter account to a master org
    function deleteVoter(string calldata _orgId, address _address) external
    {
        uint id = getVoterOrgIndex(_orgId);
        if (checkIfVoterExists(_orgId, _address)) {
            uint vId = getVoterIndex(_orgId, _address);
            orgVoterList[id].validVoterCount --;
            orgVoterList[id].voterList[vId].active = false;
            emit VoterDeleted(_orgId, _address);
        }
    }

    // function for adding an item into voting queue of the org
    function addVotingItem(string calldata _fromOrg, string calldata _orgId, PendingOpType _pendingOp) external {
        if (_pendingOp == PendingOpType.OrgAdd) {
            uint id = getVoterOrgIndex(_fromOrg);
            orgVoterList[id].pendingOp.orgId = _orgId;
            orgVoterList[id].pendingOp.opType = PendingOpType.OrgAdd;
            // init vote status
            for (uint i = 0; i < orgVoterList[id].voterList.length; i++) {
                if (orgVoterList[id].voterList[i].active) {
                    orgVoterList[id].votingStatus[id][orgVoterList[id].voterList[i].vAccount] = false;
                }
            }
            // set vote count to zero
            orgVoterList[id].voteCount = 0;
            emit VotingItemAdded(_fromOrg);

        }
    }

    // process vote and update status
    function processVote(string calldata _fromOrg, address _vAccount) external returns (bool) {
        // check if valid voter
        require(checkIfVoterExists(_fromOrg, _vAccount) == true, "must be a voter");
        uint id = getVoterOrgIndex(_fromOrg);
        require(orgVoterList[id].votingStatus[id][_vAccount] != true, "cannot double vote");
        orgVoterList[id].voteCount++;
        orgVoterList[id].votingStatus[id][msg.sender] = true;
        emit VoteProcessed(_fromOrg);
        return (orgVoterList[id].voteCount > orgVoterList[id].validVoterCount / 2);

    }

    function getVoteCount(string calldata _orgId) external view returns (uint, uint) {
        uint orgIndex = getVoterOrgIndex(_orgId);
        return (orgVoterList[orgIndex].voteCount, orgVoterList[orgIndex].validVoterCount);
    }

    function getPendingOpDetails(string calldata _orgId) external view returns (string memory, string memory, PendingOpType){
        uint orgIndex = getVoterOrgIndex(_orgId);
        return (orgVoterList[orgIndex].pendingOp.orgId, orgVoterList[orgIndex].pendingOp.enodeId, orgVoterList[orgIndex].pendingOp.opType);
    }

}

//contract NodeManager {
//    // enum and struct declaration
//    enum NodeStatus {NotInList, PendingApproval, Approved, PendingDeactivation, Deactivated, PendingActivation, PendingBlacklisting, Blacklisted}
//    struct NodeDetails {
//        string enodeId;
//        NodeStatus status;
//        string orgId;
//    }
//    // use an array to store node details
//    NodeDetails[] private nodeList;
//    mapping(bytes32 => uint) private nodeIdToIndex;
//    uint private numberOfNodes;
//
//    // store pre pending status, use for cancelPendingOperation
//    mapping(uint => NodeStatus) private prependingStatus;
//    // node permission events for new node propose
//    event NodeProposed(string _enodeId);
//    event NodeApproved(string _enodeId);
//
//    // node permission events for node decativation
//    event NodePendingDeactivation (string _enodeId);
//    event NodeDeactivated(string _enodeId);
//
//    // node permission events for node activation
//    event NodePendingActivation(string _enodeId);
//    event NodeActivated(string _enodeId);
//
//    // node permission events for node blacklist
//    event NodePendingBlacklist(string _enodeId);
//    event NodeBlacklisted(string _enodeId);
//
//    // pending operation cancelled
//    event PendingOperationCancelled(string _enodeId);
//    // Checks if the given enode exists
//    modifier enodeInList(string memory _enodeId)
//    {
//        require(nodeIdToIndex[keccak256(abi.encodePacked(_enodeId))] != 0, "Enode is not in the list");
//        _;
//    }
//
//    // Checks if the given enode does not exists
//    modifier enodeNotInList(string memory _enodeId)
//    {
//        require(nodeIdToIndex[keccak256(abi.encodePacked(_enodeId))] == 0 || getNodeStatus(_enodeId) == NodeStatus.NotInList, "Enode is in the list");
//        _;
//    }
//
//    // Get node details given enode Id
//    function getNodeDetails(string calldata enodeId) external view returns (string memory _enodeId, NodeStatus _nodeStatus)
//    {
//        uint nodeIndex = getNodeIndex(enodeId);
//        if (nodeIdToIndex[keccak256(abi.encodePacked(enodeId))] != 0) {
//            return (nodeList[nodeIndex].enodeId, nodeList[nodeIndex].status);
//        }
//        else {
//            return (enodeId, NodeStatus.NotInList);
//        }
//    }
//    // Get node details given index
//    function getNodeDetailsFromIndex(uint nodeIndex) external view returns (string memory _enodeId, NodeStatus _nodeStatus)
//    {
//        return (nodeList[nodeIndex].enodeId, nodeList[nodeIndex].status);
//    }
//
//    // Get number of nodes
//    function getNumberOfNodes() external view returns (uint)
//    {
//        return numberOfNodes;
//    }
//    // Get node status by enode id
//    function getNodeStatus(string memory _enodeId) public view enodeInList(_enodeId) returns (NodeStatus)
//    {
//        return nodeList[getNodeIndex(_enodeId)].status;
//    }
//
//    function addInitNode(string calldata _enodeId, string calldata _orgId) external {
//        numberOfNodes++;
//        nodeIdToIndex[keccak256(abi.encodePacked(_enodeId))] = numberOfNodes;
//        nodeList.push(NodeDetails(_enodeId, NodeStatus.Approved, _orgId));
//        emit NodeApproved(_enodeId);
//    }
//    // propose a new node to the network
//    function proposeNode(string calldata _enodeId, string calldata _orgId) external enodeNotInList(_enodeId)
//    {
//        if (nodeIdToIndex[keccak256(abi.encodePacked(_enodeId))] != 0) {
//            nodeList[getNodeIndex(_enodeId)].status = NodeStatus.PendingApproval;
//            prependingStatus[getNodeIndex(_enodeId)] = NodeStatus.NotInList;
//        } else {
//            // increment node number, add node to the list
//            numberOfNodes++;
//            nodeIdToIndex[keccak256(abi.encodePacked(_enodeId))] = numberOfNodes;
//            nodeList.push(NodeDetails(_enodeId, NodeStatus.PendingApproval, _orgId));
//            prependingStatus[numberOfNodes] = NodeStatus.NotInList;
//        }
//        // emit event
//        emit NodeProposed(_enodeId);
//    }
//
//    // Adds a node to the nodeList mapping and emits node approved event if successful
//    function approveNode(string calldata _enodeId) external
//    {
//        require(getNodeStatus(_enodeId) == NodeStatus.PendingApproval, "Node need to be in PendingApproval status");
//        uint nodeIndex = getNodeIndex(_enodeId);
//        nodeList[nodeIndex].status = NodeStatus.Approved;
//        emit NodeApproved(nodeList[nodeIndex].enodeId);
//    }
//
//    // Propose a node for deactivation from network
//    function proposeDeactivation(string calldata _enodeId) external enodeInList(_enodeId)
//    {
//        require(getNodeStatus(_enodeId) == NodeStatus.Approved, "Node need to be in Approved status");
//        uint nodeIndex = getNodeIndex(_enodeId);
//        prependingStatus[nodeIndex] = NodeStatus.Approved;
//        nodeList[nodeIndex].status = NodeStatus.PendingDeactivation;
//        // emit event
//        emit NodePendingDeactivation(_enodeId);
//    }
//
//    //deactivates a given Enode and emits the node decativation event
//    function deactivateNode(string calldata _enodeId) external
//    {
//        require(getNodeStatus(_enodeId) == NodeStatus.PendingDeactivation, "Node need to be in PendingDeactivation status");
//        uint nodeIndex = getNodeIndex(_enodeId);
//        nodeList[nodeIndex].status = NodeStatus.Deactivated;
//        emit NodeDeactivated(nodeList[nodeIndex].enodeId);
//    }
//
//    // Propose activation of a deactivated node
//    function proposeNodeActivation(string calldata _enodeId) external
//    {
//        require(getNodeStatus(_enodeId) == NodeStatus.Deactivated, "Node need to be in Deactivated status");
//        uint nodeIndex = getNodeIndex(_enodeId);
//        prependingStatus[nodeIndex] = NodeStatus.Deactivated;
//        nodeList[nodeIndex].status = NodeStatus.PendingActivation;
//        // emit event
//        emit NodePendingActivation(_enodeId);
//
//    }
//
//    // Activates a given Enode and emits the node activated event
//    function activateNode(string calldata _enodeId) external
//    {
//        require(getNodeStatus(_enodeId) == NodeStatus.PendingActivation, "Node need to be in PendingActivation status");
//        uint nodeIndex = getNodeIndex(_enodeId);
//        nodeList[nodeIndex].status = NodeStatus.Approved;
//        emit NodeActivated(nodeList[nodeIndex].enodeId);
//    }
//
//    // Propose node for blacklisting
//    function proposeNodeBlacklisting(string calldata _enodeId, string calldata _orgId) external
//    {
//        uint nodeIndex = getNodeIndex(_enodeId);
//        // check if node is in the nodeList
//        if (nodeIdToIndex[keccak256(abi.encodePacked(_enodeId))] != 0) {
//            // no matter what status the node is in, vote will reset and node status change to PendingBlacklisting
//            if (!(nodeList[nodeIndex].status == NodeStatus.PendingApproval || nodeList[nodeIndex].status == NodeStatus.PendingActivation || nodeList[nodeIndex].status == NodeStatus.PendingDeactivation || nodeList[nodeIndex].status == NodeStatus.PendingBlacklisting)) {
//                prependingStatus[nodeIndex] = nodeList[nodeIndex].status;
//            }
//            nodeList[nodeIndex].status = NodeStatus.PendingBlacklisting;
//            nodeIndex = getNodeIndex(_enodeId);
//        } else {
//            // increment node number, add node to the list
//            numberOfNodes++;
//            nodeIdToIndex[keccak256(abi.encodePacked(_enodeId))] = numberOfNodes;
//            nodeList.push(NodeDetails(_enodeId, NodeStatus.PendingBlacklisting, _orgId));
//            prependingStatus[nodeIndex] = NodeStatus.NotInList;
//            nodeIndex = numberOfNodes;
//        }
//        // emit event
//        emit NodePendingBlacklist(_enodeId);
//    }
//
//    //Approve node blacklisting
//    function blacklistNode(string calldata _enodeId) external
//    {
//        require(getNodeStatus(_enodeId) == NodeStatus.PendingBlacklisting, "Node need to be in PendingBlacklisting status");
//        uint nodeIndex = getNodeIndex(_enodeId);
//        nodeList[nodeIndex].status = NodeStatus.Blacklisted;
//        emit NodeBlacklisted(nodeList[nodeIndex].enodeId);
//    }
//
//    // Cancel current pending node operation
//    function cancelPendingOperation(string calldata _enodeId) external
//    {
//        require(getNodeStatus(_enodeId) == NodeStatus.PendingApproval ||
//        getNodeStatus(_enodeId) == NodeStatus.PendingActivation ||
//        getNodeStatus(_enodeId) == NodeStatus.PendingDeactivation ||
//        getNodeStatus(_enodeId) == NodeStatus.PendingBlacklisting,
//            "Node status must be in pending");
//
//        uint nodeIndex = getNodeIndex(_enodeId);
//        nodeList[nodeIndex].status = prependingStatus[nodeIndex];
//        emit PendingOperationCancelled(_enodeId);
//    }
//    // Returns the node index based on enode id
//    function getNodeIndex(string memory _enodeId) internal view returns (uint)
//    {
//        return nodeIdToIndex[keccak256(abi.encodePacked(_enodeId))] - 1;
//    }
//
//}

contract OrgManagement {
    AccountManager private accounts;
    RoleManager private roles;
    OrgVoterManager private orgVoters;
    //    NodeManager private nodes;

    string private adminOrgId;
    string private adminRole;

    // checks if first time network boot up has happened or not
    bool private networkBoot = false;

    enum OrgStatus {NotInList, Proposed, Approved, PendingRemoval, Removed, PendingReenabling}
    struct OrgDetails {
        string orgId;
        OrgStatus status;
    }

    OrgDetails [] private orgList;
    mapping(bytes32 => uint) private OrgIndex;
    uint private orgNum = 0;

    // events related to Master Org add
    event OrgApproved(string _orgId);
    event OrgPendingApproval(string _orgId, OrgStatus _type);
    event OrgRemoved(string _orgId);

    function init() external {
        // init will be called only once when the network starts
        // networkBoot will be updated to true post init
        require(networkBoot == false, "Invalid call: Network boot up completed");

        adminOrgId = "NETWORKADMIN";
        adminRole = "NETWORKADMIN";

        roles = new RoleManager(adminRole, adminOrgId, RoleManager.AccountAccess.FullAccess, true);
        accounts = new AccountManager();
        orgVoters = new OrgVoterManager();
        //        nodes = new NodeManager();

        // Create the new "NETWORKADMIN" org
        addAdminOrg(adminOrgId);

        // Create the "NETWORKADMIN" role
//        addAdminRole(adminRole, adminOrgId);

    }

    function addAdminOrg(string memory _orgId) internal {
        require(networkBoot == false, "Invalid call: Network boot up completed");
        orgNum++;
        OrgIndex[keccak256(abi.encodePacked(_orgId))] = orgNum;
        uint id = orgList.length++;
        orgList[id].orgId = _orgId;
        orgList[id].status = OrgStatus.Approved;
        emit OrgApproved(_orgId);
    }

//    function addAdminRole(string memory _roleId, string memory _orgId) internal {
//        require(networkBoot == false, "Invalid call: Network boot up completed");
//        roles.addRole(_roleId, _orgId, RoleManager.AccountAccess.FullAccess, true);
//    }

    //    function addAdminNodes(string calldata _enodeId) external {
    //        require(networkBoot == false, "Invalid call: Network boot up completed");
    //        nodes.addInitNode(_enodeId, adminOrgId);
    //    }

    function addAdminAccounts(address _acct) external {
        require(networkBoot == false, "Invalid call: Network boot up completed");
        assignAccountRole(_acct, adminOrgId, adminRole);
    }

    // update the network boot status as true
    function updateNetworkBootStatus() external returns (bool)
    {
        require(networkBoot == false, "Invalid call: Network boot up completed");
        networkBoot = true;
        return networkBoot;
    }

    // Org related functions
    // returns the org index for the org list
    function getOrgIndex(string memory _orgId) internal view returns (uint)
    {
        return OrgIndex[keccak256(abi.encodePacked(_orgId))] - 1;
    }

    // Get network boot status
    function getNetworkBootStatus() external view returns (bool)
    {
        return networkBoot;
    }

    // function for adding a new master org
    function addOrg(string calldata _orgId) external
    {
        require(checkOrgExists(_orgId) == false, "Org already exists");

        orgNum++;
        OrgIndex[keccak256(abi.encodePacked(_orgId))] = orgNum;
        uint id = orgList.length++;
        orgList[id].orgId = _orgId;
        orgList[id].status = OrgStatus.Proposed;
        // org add has to be approved by network admin org. create an item for approval
        orgVoters.addVotingItem(adminOrgId, _orgId, OrgVoterManager.PendingOpType.OrgAdd);

        emit OrgPendingApproval(_orgId, OrgStatus.Proposed);
    }

    // function for adding a new master org
    function removeOrg(string calldata _orgId) external
    {
        require(checkOrgExists(_orgId) == false, "Org already exists");
        uint id = getOrgIndex(_orgId);
        require(orgList[id].status == OrgStatus.Approved);
        orgList[id].status = OrgStatus.PendingRemoval;

        orgVoters.addVotingItem(adminOrgId, _orgId, OrgVoterManager.PendingOpType.OrgRemoval);
        emit OrgPendingApproval(_orgId, OrgStatus.Proposed);
    }

    function approveOrg(string calldata _orgId) external
    {
        require (checkOrgApproved(_orgId) == false, "Nothing to approve");
        bool majority = orgVoters.processVote(adminOrgId, msg.sender);
        // if majority achieved update the org status to approved
        if (majority) {
            uint id = getOrgIndex(_orgId);
            orgList[id].status = OrgStatus.Approved;
            emit OrgApproved(_orgId);
        }
    }

    function approveRemoval(string calldata _orgId) external
    {
        require (checkOrgPendingRemoval(_orgId) == false, "Nothing to approve");
        bool majority = orgVoters.processVote(adminOrgId, msg.sender);
        // if majority achieved update the org status to approved
        if (majority) {
            uint id = getOrgIndex(_orgId);
            orgList[id].status = OrgStatus.Removed;
            emit OrgApproved(_orgId);
        }
    }

    // function to check if morg exists
    function checkOrgExists(string memory _orgId) public view returns (bool) {
        return (!(OrgIndex[keccak256(abi.encodePacked(_orgId))] == 0));
    }

    // function to check if morg exists
    function checkOrgApproved(string memory _orgId) public view returns (bool) {
        uint id = getOrgIndex(_orgId);
        return ((OrgIndex[keccak256(abi.encodePacked(_orgId))] != 0) && orgList[id].status == OrgStatus.Approved);
    }

    // function to check if morg exists
    function checkOrgPendingRemoval(string memory _orgId) public view returns (bool) {
        uint id = getOrgIndex(_orgId);
        return ((OrgIndex[keccak256(abi.encodePacked(_orgId))] != 0) && orgList[id].status == OrgStatus.PendingRemoval);
    }

    // returns org and master org details based on org index
    function getOrgInfo(uint _orgIndex) external view returns (string memory, OrgStatus status){
        return (orgList[_orgIndex].orgId, orgList[_orgIndex].status);
    }

    // Account related functions
    function getContractAddresses() external view returns (address, address, address){
        return (address(accounts), address(roles), address(orgVoters));
    }

    function assignAccountRole(address _acct, string memory _orgId, string memory _roleId) public {
        bool newRoleVoter = roles.isVoterRole(_roleId, _orgId);
        // check the role of the account. if the current role is voter and new role is also voter
        // voterlist change is not required. else voter list needs to be changed
        string memory acctRole = accounts.getAccountRole(_acct);
        if (keccak256(abi.encodePacked(acctRole)) == keccak256(abi.encodePacked("NONE"))) {
            //new account
            if (newRoleVoter) {
                // add to voter list
                orgVoters.addVoter(_orgId, _acct);
            }
        }
        else {
            bool currRoleVoter = roles.isVoterRole(acctRole, _orgId);
            if (!(currRoleVoter && newRoleVoter)) {
                if (newRoleVoter) {
                    // add to voter list
                    orgVoters.addVoter(_orgId, _acct);
                }
                else {
                    // delete from voter list
                    orgVoters.deleteVoter(_orgId, _acct);
                }
            }
        }
        accounts.assignAccountRole(_acct, _orgId, _roleId);
    }

    function getAccountDetails(address _acct) external view returns (address acct, string memory orgId, string memory role, bool active){
        address locAcct;
        string memory locRole;
        string memory locOrgId;
        bool status;

        (locAcct, locOrgId, locRole, status) = accounts.getAccountDetails(_acct);

        return (locAcct, locOrgId, locRole, status);

    }

    // Role related functions
    function addNewRole(string calldata _roleId, string calldata _orgId, RoleManager.AccountAccess _access, bool _voter) external {
        // org should be approved for the role to be added
        require(checkOrgApproved(_orgId) == true, "Org not approved");
        roles.addRole(_roleId, _orgId, _access, _voter);
    }

    function removeRole(string calldata _roleId, string calldata _orgId) external {
        require(checkOrgApproved(_orgId) == true, "Org not approved");
        roles.removeRole(_roleId, _orgId);
    }

    function getRoleDetails(string calldata _roleId, string calldata _orgId) external view returns (string memory roleId, string memory orgId, RoleManager.AccountAccess accessType, bool isVoter, bool active){
        string memory locRoleId;
        string memory locOrgId;
        RoleManager.AccountAccess locAccessType;
        bool status;
        bool locVoter;

        (locRoleId, locOrgId, locAccessType, locVoter, status) = roles.getRoleDetails(_roleId, _orgId);

        return (locRoleId, locOrgId, accessType, locVoter, status);

    }

    // Org voter related functions
    function getNumberOfVoters(string calldata _orgId) external view returns (uint){
        uint voterCount = orgVoters.getNumberOfValidVoters(_orgId);
        return voterCount;
    }

    function checkIfVoterExists(string calldata _orgId, address _acct) external view returns (bool) {
        bool voterExists = orgVoters.checkIfVoterExists(_orgId, _acct);
        return voterExists;
    }

    function getVoteCount(string calldata _orgId) external view returns (uint, uint) {
        uint voteCnt = 0;
        uint totVoters = 0;

        (voteCnt, totVoters) = orgVoters.getVoteCount(_orgId);

        return (voteCnt, totVoters);
    }

    function getPendingOp() external view returns (string memory orgId, string memory enodeId, OrgVoterManager.PendingOpType pendingOp){
        string memory locEnodeId;
        string memory locOrgId;
        OrgVoterManager.PendingOpType locPendingOp;
        (locEnodeId, locOrgId, locPendingOp) = orgVoters.getPendingOpDetails(adminOrgId);

        return (locEnodeId, locOrgId, locPendingOp);
    }

    // Node related functions
    //    function proposeNode(string calldata _enodeId, string calldata _orgId) external {
    //        nodes.proposeNode(_enodeId, _orgId);
    //    }
    //
    //    function approveNode(string calldata _enodeId) external {
    //        nodes.approveNode(_enodeId);
    //    }
    //
    //    function proposeNodeDeactivation(string calldata _enodeId) external {
    //        nodes.proposeDeactivation(_enodeId);
    //    }
    //
    //    function approveNodeDeactivation(string calldata _enodeId) external {
    //        nodes.deactivateNode(_enodeId);
    //    }
    //
    //    function proposeNodeActivation(string calldata _enodeId) external {
    //        nodes.proposeNodeActivation(_enodeId);
    //    }
    //
    //    function approveNodeActivation(string calldata _enodeId) external {
    //        nodes.activateNode(_enodeId);
    //    }
    //
    //    // Node related functions
    //    function proposeNodeBlacklisting(string calldata _enodeId, string calldata _orgId) external {
    //        nodes.proposeNodeBlacklisting(_enodeId, _orgId);
    //    }
    //
    //    function approveNodeBlacklisting(string calldata _enodeId) external {
    //        nodes.blacklistNode(_enodeId);
    //    }

}